/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  CurrentFolderNotesDisplayView: () => CurrentFolderNotesDisplayView,
  VIEW_TYPE_CURRENT_FOLDER_NOTES_DISPLAY: () => VIEW_TYPE_CURRENT_FOLDER_NOTES_DISPLAY,
  default: () => CurrentFolderNotesDisplay
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_obsidian2 = require("obsidian");
var import_obsidian3 = require("obsidian");
var import_obsidian4 = require("obsidian");
var DEFAULT_SETTINGS = {
  excludeTitlesFilter: "_index",
  includeTitleFilter: "",
  prettyTitleCase: true,
  includeSubfolderNotes: false,
  includeCurrentFileOutline: true,
  includeListFileOutlines: false,
  styleMode: "fancy",
  showNavigation: false,
  biggerText: false,
  biggerTextMobileOnly: false
  // Add default value
};
var CurrentFolderNotesDisplay = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.leaves = [];
  }
  fileChangeHandler(file) {
    if (file instanceof import_obsidian.TFile) {
      this.load();
    }
  }
  async onload() {
    await this.loadSettings();
    this.loadStyles();
    this.addSettingTab(new CurrentFolderNotesDisplaySettingTab(this.app, this));
    this.registerView(VIEW_TYPE_CURRENT_FOLDER_NOTES_DISPLAY, (leaf) => new CurrentFolderNotesDisplayView(leaf, this));
    this.addRibbonIcon("folder", "Activate folder notes display", () => {
      this.activateView();
    });
    this.addCommand({
      id: "activate-folder-notes-display",
      name: "Open Pane",
      callback: () => {
        this.activateView();
      }
    });
    let refreshTimeout = null;
    const debouncedRefresh = () => {
      if (refreshTimeout)
        clearTimeout(refreshTimeout);
      refreshTimeout = setTimeout(() => {
        this.refreshView();
      }, 300);
    };
    this.registerEvent(this.app.workspace.on("file-open", debouncedRefresh));
    this.registerEvent(this.app.vault.on("delete", debouncedRefresh));
    this.registerEvent(this.app.vault.on("create", debouncedRefresh));
    this.registerEvent(this.app.vault.on("rename", debouncedRefresh));
  }
  async onunload() {
    console.log("unloading plugin");
    const leavesToDetach = this.app.workspace.getLeavesOfType(VIEW_TYPE_CURRENT_FOLDER_NOTES_DISPLAY);
    leavesToDetach.forEach((leaf) => {
      leaf.detach();
    });
    this.leaves = [];
  }
  async activateView() {
    const { workspace } = this.app;
    const existingLeaves = workspace.getLeavesOfType(VIEW_TYPE_CURRENT_FOLDER_NOTES_DISPLAY);
    if (existingLeaves.length > 1) {
      for (let i = 1; i < existingLeaves.length; i++) {
        existingLeaves[i].detach();
      }
    }
    let leaf = null;
    if (existingLeaves.length) {
      leaf = existingLeaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_CURRENT_FOLDER_NOTES_DISPLAY, active: true });
        this.leaves.push(leaf);
      }
    }
    if (!leaf) {
      new import_obsidian.Notice("Could not create a new leaf for the view");
      return;
    }
    workspace.revealLeaf(leaf);
  }
  async refreshView() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CURRENT_FOLDER_NOTES_DISPLAY);
    if (leaves.length > 1) {
      for (let i = 1; i < leaves.length; i++) {
        leaves[i].detach();
      }
    }
    if (leaves.length === 1) {
      const view = leaves[0].view;
      await view.displayNotesInCurrentFolder();
    } else if (leaves.length === 0) {
      this.activateView();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Add this method to load styles
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "current-folder-notes-styles";
    document.head.appendChild(styleEl);
    this.register(() => styleEl.remove());
    this.loadData().then((data) => {
      const defaultStyles = `
				.folder-notes-style { font-weight: 500; }
				.folder-notes-style.current-file { font-weight: bold; }
				.hover-style-file { text-decoration: underline; }
				.hover-style-heading { font-style: italic; }
				/* Add more default styles as needed */
			`;
      styleEl.textContent = defaultStyles;
    });
  }
};
var VIEW_TYPE_CURRENT_FOLDER_NOTES_DISPLAY = "current-folder-notes-view";
var CurrentFolderNotesDisplayView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CURRENT_FOLDER_NOTES_DISPLAY;
  }
  getDisplayText() {
    return "Current Folder Notes";
  }
  getIcon() {
    return "folder";
  }
  async onOpen() {
    await this.displayNotesInCurrentFolder();
  }
  async onClose() {
    const index = this.plugin.leaves.indexOf(this.leaf);
    if (index > -1) {
      this.plugin.leaves.splice(index, 1);
    }
  }
  // main.ts
  // Function to create clickable headings
  createClickableHeadings(container, currentFileContent, currentFilePath, addExtraHeadingCSS) {
    const MAX_CONTENT_SIZE = 5e5;
    if (currentFileContent.length > MAX_CONTENT_SIZE) {
      currentFileContent = currentFileContent.substring(0, MAX_CONTENT_SIZE);
      container.createEl("p", {
        cls: "content-truncated-note",
        text: "Note is very large. Only showing headings from the first portion."
      });
    }
    const headingRegex = /^(#+)\s+(.*)$/gm;
    let match;
    let headingCount = 0;
    const MAX_HEADINGS = 100;
    try {
      while ((match = headingRegex.exec(currentFileContent)) !== null && headingCount < MAX_HEADINGS) {
        const headingLevel = match[1].length;
        let headingText = match[2];
        headingText = this.extractAlias(headingText);
        let headingLabel = "\u2192 " + headingText;
        const p = container.createEl("p", { text: headingLabel });
        p.classList.add("basic-heading");
        p.classList.add(`heading-level-${headingLevel}`);
        if (addExtraHeadingCSS) {
          p.classList.add("extra-heading-style");
        }
        p.addEventListener("click", (event) => {
          event.preventDefault();
          this.app.workspace.openLinkText("#" + headingText, currentFilePath);
          const selection = window.getSelection();
          if (selection) {
            selection.removeAllRanges();
          }
        });
        p.onmouseover = () => {
          p.classList.add("hover-style-heading");
        };
        p.onmouseout = () => {
          p.classList.remove("hover-style-heading");
        };
        headingCount++;
      }
      if (headingCount >= MAX_HEADINGS) {
        container.createEl("p", {
          cls: "more-headings-note",
          text: "... more headings available (not shown)"
        });
      }
    } catch (err) {
      console.error("Error processing headings:", err);
      container.createEl("p", {
        cls: "error-note",
        text: "Error processing headings"
      });
    }
  }
  // Function to extract alias from heading text
  extractAlias(headingText) {
    const matches = headingText.match(/\[\[.*\|(.*?)\]\]/);
    return matches ? matches[1] : headingText;
  }
  getShortNoteName(basename) {
    const tMatch = basename.match(/T(\d+)/);
    if (tMatch)
      return `T${tMatch[1]}`;
    const yMatch = basename.match(/Y(\d+)/);
    if (yMatch)
      return `Y${yMatch[1]}`;
    const numberMatch = basename.match(/\d+/);
    if (numberMatch)
      return numberMatch[0];
    const dashMatch = basename.match(/-\s*(.+)$/);
    if (dashMatch)
      return dashMatch[1];
    return basename;
  }
  async displayNotesInCurrentFolder() {
    const container = this.containerEl.children[1];
    container.empty();
    const styleMode = this.plugin.settings.styleMode;
    const showNavigation = this.plugin.settings.showNavigation;
    const headerContainer = container.createDiv({ cls: "folder-view-header" });
    headerContainer.createEl("h6", { text: "Current Folder Notes" });
    const activeFile = this.app.workspace.getActiveFile();
    const currentFilePath = activeFile ? activeFile.path : "";
    let parentFolderPath = "";
    if (currentFilePath) {
      const lastSlashIndex = currentFilePath.lastIndexOf("/");
      parentFolderPath = lastSlashIndex > 0 ? currentFilePath.substring(0, lastSlashIndex) : "";
    } else if (this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView)) {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (activeView == null ? void 0 : activeView.file) {
        const viewFilePath = activeView.file.path;
        const lastSlashIndex = viewFilePath.lastIndexOf("/");
        parentFolderPath = lastSlashIndex > 0 ? viewFilePath.substring(0, lastSlashIndex) : "";
      }
    }
    if (!parentFolderPath) {
      const warningDiv = container.createDiv({ cls: "empty-state-message" });
      warningDiv.createEl("p", {
        text: "Please open a note in a folder to view related notes.",
        cls: "empty-state-highlight"
      });
      warningDiv.createEl("p", {
        text: "The root folder cannot be shown to prevent performance issues with large vaults.",
        cls: "empty-state-subtext"
      });
      return;
    }
    const pathDisplay = headerContainer.createEl("div", {
      cls: "folder-path-display",
      text: parentFolderPath
    });
    pathDisplay.style.fontSize = "var(--font-smaller)";
    pathDisplay.style.color = "var(--text-muted)";
    pathDisplay.style.marginBottom = "10px";
    pathDisplay.style.wordBreak = "break-word";
    let folder = this.app.vault.getAbstractFileByPath(parentFolderPath);
    let files = [];
    if (folder instanceof import_obsidian4.TFolder) {
      files = folder.children.filter((file) => file instanceof import_obsidian.TFile);
    }
    files = this.applyFilters(files, parentFolderPath);
    if (files.length === 0) {
      this.showEmptyState(container, activeFile, currentFilePath, files);
      return;
    }
    const sequenceWithPrefixOrLongest = (str) => {
      const tMatches = str.match(/T(\d+)/);
      if (tMatches)
        return parseInt(tMatches[1]);
      const yMatches = str.match(/Y(\d+)/);
      if (yMatches)
        return parseInt(yMatches[1]) + 1e3;
      const matches = str.match(/\d+/g) || [];
      return Math.max(...matches.map((numStr) => parseInt(numStr)), 0);
    };
    files.sort((a, b) => sequenceWithPrefixOrLongest(a.basename) - sequenceWithPrefixOrLongest(b.basename));
    const currentFileIndex = files.findIndex((file) => file.path === currentFilePath);
    const mainContent = container.createDiv({ cls: "main-content" });
    if (showNavigation && currentFileIndex !== -1) {
      const navigationSection = mainContent.createDiv({ cls: "navigation-section" });
      const navHeader = navigationSection.createDiv({ cls: "navigation-header" });
      if (currentFileIndex > 0) {
        const prevNote = files[currentFileIndex - 1];
        const prevLink = navHeader.createDiv({ cls: "nav-link prev-note" });
        const prevIcon = prevLink.createSpan({ cls: "nav-icon" });
        prevIcon.innerHTML = `<svg viewBox="0 0 100 100" class="arrow-left" width="16" height="16"><path fill="currentColor" stroke="currentColor" d="M 60,20 L 30,50 L 60,80"></path></svg>`;
        prevLink.createSpan({ cls: "nav-direction", text: "Previous" });
        const prevTitle = prevLink.createSpan({
          cls: "nav-title",
          text: this.getShortNoteName(prevNote.basename)
        });
        prevLink.setAttribute("aria-label", `Previous: ${prevNote.basename}`);
        prevLink.addEventListener("click", () => {
          this.app.workspace.openLinkText(prevNote.basename, parentFolderPath);
        });
      }
      if (currentFileIndex < files.length - 1) {
        const nextNote = files[currentFileIndex + 1];
        const nextLink = navHeader.createDiv({ cls: "nav-link next-note" });
        nextLink.createSpan({ cls: "nav-direction", text: "Next" });
        const nextIcon = nextLink.createSpan({ cls: "nav-icon" });
        nextIcon.innerHTML = `<svg viewBox="0 0 100 100" class="arrow-right" width="16" height="16"><path fill="currentColor" stroke="currentColor" d="M 40,20 L 70,50 L 40,80"></path></svg>`;
        const nextTitle = nextLink.createSpan({
          cls: "nav-title",
          text: this.getShortNoteName(nextNote.basename)
        });
        nextLink.setAttribute("aria-label", `Next: ${nextNote.basename}`);
        nextLink.addEventListener("click", () => {
          this.app.workspace.openLinkText(nextNote.basename, parentFolderPath);
        });
      }
      if (this.plugin.settings.includeCurrentFileOutline) {
        const currentFile = files[currentFileIndex];
        const outlineSection = navigationSection.createDiv({ cls: "outline-section" });
        outlineSection.createEl("div", {
          cls: "current-note-title",
          text: currentFile.basename
        });
        outlineSection.createEl("div", {
          cls: "folder-section-header",
          text: "CURRENT NOTE OUTLINE"
        });
        const loadingEl = outlineSection.createEl("div", {
          cls: "loading-indicator",
          text: "Loading outline..."
        });
        setTimeout(async () => {
          const fileContent = await this.app.vault.read(currentFile);
          if (fileContent) {
            loadingEl.remove();
            this.createClickableHeadings(outlineSection, fileContent, currentFile.path, true);
          } else {
            loadingEl.setText("No content found");
          }
        }, 10);
      }
      mainContent.createDiv({ cls: "section-separator" });
    }
    const listContainer = mainContent.createDiv({ cls: "notes-flat-list" });
    listContainer.createEl("div", {
      cls: "folder-section-header",
      text: "FOLDER NOTES"
    });
    const MAX_FILES_DISPLAY = 100;
    const displayedFiles = files.slice(0, MAX_FILES_DISPLAY);
    const hasMoreFiles = files.length > MAX_FILES_DISPLAY;
    const BATCH_SIZE = 20;
    const processBatch = async (startIdx) => {
      const endIdx = Math.min(startIdx + BATCH_SIZE, displayedFiles.length);
      for (let i = startIdx; i < endIdx; i++) {
        const file = displayedFiles[i];
        const isCurrentFile = file.path === currentFilePath;
        const fileContainer = listContainer.createDiv({
          cls: isCurrentFile ? "file-container current" : "file-container"
        });
        this.createFileLink(fileContainer, file, currentFilePath, parentFolderPath);
        if (this.plugin.settings.includeListFileOutlines) {
          const outlinePlaceholder = fileContainer.createEl("div", {
            cls: "outline-placeholder",
            text: "Loading outline..."
          });
          requestAnimationFrame(async () => {
            try {
              const fileContent = await this.app.vault.read(file);
              outlinePlaceholder.remove();
              if (fileContent) {
                this.createClickableHeadings(fileContainer, fileContent, file.path, isCurrentFile);
              }
            } catch (err) {
              console.error("Error loading outline:", err);
              outlinePlaceholder.setText("Failed to load outline");
            }
          });
        }
      }
      if (endIdx < displayedFiles.length) {
        setTimeout(() => processBatch(endIdx), 50);
      }
      if (hasMoreFiles && endIdx === displayedFiles.length) {
        listContainer.createEl("div", {
          cls: "more-files-message",
          text: `Showing ${MAX_FILES_DISPLAY} of ${files.length} notes. Use filters to narrow results.`
        });
      }
    };
    processBatch(0);
    container.classList.add("compact-mode");
    container.classList.toggle("minimal-style", styleMode === "minimal");
    container.classList.toggle("fancy-style", styleMode === "fancy");
    container.classList.toggle("neobrutalist-style", styleMode === "neobrutalist");
    const shouldApplyBiggerText = this.plugin.settings.biggerText && (!this.plugin.settings.biggerTextMobileOnly || this.app.isMobile);
    container.classList.toggle("bigger-text", shouldApplyBiggerText);
  }
  // Helper function to create file links with consistent styling
  createFileLink(container, file, currentFilePath, parentFolderPath) {
    const p = container.createEl("p");
    const a = p.createEl("a", { text: file.basename });
    if (this.plugin.settings.prettyTitleCase) {
      a.innerText = a.innerText.replace(/\w\S*/g, function(txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    }
    a.className = "folder-notes-style";
    if (file.path === currentFilePath) {
      a.className += " current-file";
      a.innerText = "\u2605 " + a.innerText;
    }
    a.onmouseover = () => a.classList.add("hover-style-file");
    a.onmouseout = () => a.classList.remove("hover-style-file");
    a.addEventListener("click", () => {
      this.app.workspace.openLinkText(file.basename, parentFolderPath);
    });
  }
  // Helper method to show empty state
  showEmptyState(container, activeFile, currentFilePath, files) {
    const emptyStateDiv = container.createDiv({ cls: "empty-state-message" });
    if (files.length === 0) {
      emptyStateDiv.createEl("p", {
        text: "No notes found. If you have recently added or moved notes, Obsidian might still be indexing them. Please wait a moment and try again.",
        cls: "empty-state-highlight"
      });
    }
    if (this.plugin.settings.includeTitleFilter) {
      emptyStateDiv.createEl("p", {
        text: `\u{1F50D} No notes match the current filter "${this.plugin.settings.includeTitleFilter}".`,
        cls: "empty-state-highlight"
      });
    } else if (this.plugin.settings.excludeTitlesFilter) {
      emptyStateDiv.createEl("p", {
        text: `All notes are currently filtered out by the exclude pattern "${this.plugin.settings.excludeTitlesFilter}"`
      });
    } else {
      emptyStateDiv.createEl("p", {
        text: "This folder is empty"
      });
    }
    if (currentFilePath && activeFile) {
      emptyStateDiv.createEl("p", {
        text: "Showing outline of current note:",
        cls: "empty-state-subtext"
      });
      const loadingEl = emptyStateDiv.createEl("div", {
        cls: "loading-indicator",
        text: "Loading outline..."
      });
      setTimeout(async () => {
        try {
          const fileContent = await this.app.vault.read(activeFile);
          if (fileContent) {
            loadingEl.remove();
            const contentSize = fileContent.length;
            if (contentSize > 1e5) {
              const truncatedContent = fileContent.substring(0, 1e5);
              this.createClickableHeadings(container, truncatedContent, currentFilePath, true);
              container.createEl("p", {
                text: "Note is very large. Only showing first portion of headings.",
                cls: "empty-state-subtext"
              });
            } else {
              this.createClickableHeadings(container, fileContent, currentFilePath, true);
            }
          } else {
            loadingEl.setText("No content found");
          }
        } catch (err) {
          console.error("Error loading outline:", err);
          loadingEl.setText("Failed to load outline");
        }
      }, 10);
    }
  }
  applyFilters(files, parentFolderPath) {
    return files.filter((file) => {
      if (!this.plugin.settings.includeSubfolderNotes && file.path.substring(parentFolderPath.length + 1).includes("/")) {
        return false;
      }
      const lowerBasename = file.basename.toLowerCase();
      const excludeFilter = this.plugin.settings.excludeTitlesFilter;
      if (excludeFilter && excludeFilter.length > 0) {
        const excludeWords = excludeFilter.split(/[,\s]+/).filter((word) => word.trim().length > 0).map((word) => word.trim().toLowerCase());
        if (excludeWords.length > 0 && excludeWords.some((word) => lowerBasename.includes(word))) {
          return false;
        }
      }
      const includesFilter = this.plugin.settings.includeTitleFilter;
      if (includesFilter && includesFilter.length > 0) {
        const includeWords = includesFilter.split(/[,\s]+/).filter((word) => word.trim().length > 0).map((word) => word.trim().toLowerCase());
        if (includeWords.length > 0 && !includeWords.some((word) => lowerBasename.includes(word))) {
          return false;
        }
      }
      return true;
    });
  }
};
var CurrentFolderNotesDisplaySettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("style", {
      text: `
				.settings-section {
					margin-bottom: 24px;
					border-bottom: 1px solid var(--background-modifier-border);
					padding-bottom: 16px;
				}
				.settings-section-header {
					margin-bottom: 12px;
					font-size: 16px;
					font-weight: 600;
					color: var(--text-normal);
				}
				.settings-section-description {
					margin-bottom: 12px;
					font-size: 13px;
					color: var(--text-muted);
				}
				.setting-item {
					border-top: none !important;
					padding-top: 12px !important;
				}
				.setting-item-description {
					font-size: 12px !important;
				}
			`
    });
    const titleEl = containerEl.createDiv({ cls: "settings-section" });
    titleEl.createEl("h2", { text: "Current Folder Notes Settings" });
    titleEl.createEl("p", {
      cls: "settings-section-description",
      text: "Configure how notes from the current folder are displayed in the panel."
    });
    const filtersEl = containerEl.createDiv({ cls: "settings-section" });
    filtersEl.createEl("h3", { cls: "settings-section-header", text: "\u{1F4C2} Filter Settings" });
    filtersEl.createEl("p", {
      cls: "settings-section-description",
      text: "Control which notes appear in the folder notes panel."
    });
    new import_obsidian.Setting(filtersEl).setName("Exclude titles filter").setDesc("Notes containing these words will be hidden. Separate multiple words with commas.").addText((text) => text.setPlaceholder("_index, draft, template").setValue(this.plugin.settings.excludeTitlesFilter).onChange(async (value) => {
      this.plugin.settings.excludeTitlesFilter = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(filtersEl).setName("Include titles filter").setDesc("Only notes containing these words will be shown. Leave empty to show all notes. Separate multiple words with commas.").addText((text) => text.setPlaceholder("chapter, section, lesson").setValue(this.plugin.settings.includeTitleFilter).onChange(async (value) => {
      this.plugin.settings.includeTitleFilter = value;
      await this.plugin.saveSettings();
    }));
    const displayEl = containerEl.createDiv({ cls: "settings-section" });
    displayEl.createEl("h3", { cls: "settings-section-header", text: "\u{1F5A5}\uFE0F Display Options" });
    displayEl.createEl("p", {
      cls: "settings-section-description",
      text: "Control how notes and their contents are displayed in the panel."
    });
    new import_obsidian.Setting(displayEl).setName("Show navigation").setDesc("Show navigation links for previous and next notes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showNavigation).onChange(async (value) => {
      this.plugin.settings.showNavigation = value;
      await this.plugin.saveSettings();
      this.plugin.refreshView();
    }));
    new import_obsidian.Setting(displayEl).setName("Pretty title case").setDesc("Convert note titles to Title Case for better readability.").addToggle((toggle) => toggle.setValue(this.plugin.settings.prettyTitleCase).onChange(async (value) => {
      this.plugin.settings.prettyTitleCase = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(displayEl).setName("Style mode").setDesc("Choose between minimal, fancy, and neobrutalist styles.").addDropdown((dropdown) => dropdown.addOption("minimal", "Minimal").addOption("fancy", "Fancy").addOption("neobrutalist", "Neobrutalist").setValue(this.plugin.settings.styleMode).onChange(async (value) => {
      this.plugin.settings.styleMode = value;
      await this.plugin.saveSettings();
      this.plugin.refreshView();
    }));
    new import_obsidian.Setting(displayEl).setName("Bigger text").setDesc("Make all the text bigger for easier clicking.").addToggle((toggle) => toggle.setValue(this.plugin.settings.biggerText).onChange(async (value) => {
      this.plugin.settings.biggerText = value;
      await this.plugin.saveSettings();
      this.plugin.refreshView();
    }));
    new import_obsidian.Setting(displayEl).setName("Mobile-only bigger text").setDesc("Only apply bigger text when using Obsidian on mobile devices.").addToggle((toggle) => toggle.setValue(this.plugin.settings.biggerTextMobileOnly).onChange(async (value) => {
      this.plugin.settings.biggerTextMobileOnly = value;
      await this.plugin.saveSettings();
      this.plugin.refreshView();
    }));
    const contentEl = containerEl.createDiv({ cls: "settings-section" });
    contentEl.createEl("h3", { cls: "settings-section-header", text: "\u{1F4DD} Content Options" });
    contentEl.createEl("p", {
      cls: "settings-section-description",
      text: "Configure what content is included in the folder notes panel."
    });
    new import_obsidian.Setting(contentEl).setName("Include subfolder notes").setDesc("Show notes from subfolders within the current folder.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeSubfolderNotes).onChange(async (value) => {
      this.plugin.settings.includeSubfolderNotes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(contentEl).setName("Show outline in current file section").setDesc("Display headings from the currently active file at the top of the panel.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeCurrentFileOutline).onChange(async (value) => {
      this.plugin.settings.includeCurrentFileOutline = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(contentEl).setName("Show outline in files list").setDesc("Display headings under each file in the folder notes list.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeListFileOutlines).onChange(async (value) => {
      this.plugin.settings.includeListFileOutlines = value;
      await this.plugin.saveSettings();
    }));
    const aboutEl = containerEl.createDiv({ cls: "settings-section" });
    aboutEl.createEl("h3", { cls: "settings-section-header", text: "\u2139\uFE0F About" });
    aboutEl.createEl("p", {
      cls: "settings-section-description",
      text: "Current Folder Notes displays notes and outlines from the current folder for quick navigation. Changes to settings will apply immediately."
    });
    new import_obsidian.Setting(aboutEl).setName("Refresh panel").setDesc("Manually refresh the Current Folder Notes panel to apply changes.").addButton((button) => button.setButtonText("Refresh Now").setCta().onClick(() => {
      this.plugin.refreshView();
      new import_obsidian.Notice("Current Folder Notes panel refreshed");
    }));
  }
};

/* nosourcemap */